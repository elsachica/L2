# Reflektioner från kapitel 2 och 3

## Kapitel 2

| Namn                    | Typ         | Regel från Clean Code              | Reflektion och tillämpning av regler                                                                                     |
|-------------------------|-------------|-----------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| PostalCodeValidator     | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör. Det är ett bra namn enligt regeln om intention-revealing names, vilket gör koden lättare att förstå och använda. |
| validatePostalCode()    | Metodnamn   | Method Names                       | Metodnamnet är verbbaserat och beskriver funktionens syfte. Denna metod stödjer postnummer från USA, Sverige. Att specificera vilka länder som stöds direkt i metoden (t.ex. `validatePostalCodeForMultipleCountries()`) skulle vara en förbättring, men det nuvarande namnet är fortfarande tydligt. |
| PhoneNumberValidator    | Klassnamn   | Use Intention-Revealing Names      | Klassen är namngiven så att dess syfte är klart och tydligt. Det är ett bra exempel på intention-revealing names och följer regeln för att använda beskrivande och förståeliga namn. |
| validatePhoneNumber()   | Metodnamn   | Method Names                       | Metodnamnet är verbbaserat och beskriver tydligt vad funktionen gör. Det hanterar flera länders telefonformat (Sverige, USA, Storbritannien och Spanien), vilket gör att det är relevant för olika användares behov. Att ha metoden namngiven som `validatePhoneNumber` är passande eftersom det direkt förmedlar syftet. |
| PasswordValidator       | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är klart och tydligt. Det beskriver exakt vad klassen gör, vilket är en bra tillämpning av regeln för intention-revealing names. |
| validatePassword()      | Metodnamn   | Method Names                       | Metodnamnet `validatePassword()` är enkelt och tydligt, vilket gör det lätt att förstå vid första anblick. Det beskriver exakt vad metoden gör – den validerar ett lösenord. |
| EmailValidator          | Klassnamn   | Use Intention-Revealing Names      | Klassen är namngiven på ett sätt som tydligt anger vad den validerar. Det är ett bra exempel på att använda beskrivande och intention-revealing names. |
| validateEmail()         | Metodnamn   | Method Names                       | Metodnamnet är tydligt och använder ett verb. |
| DateFormatValidator     | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör, vilket följer regeln om intention-revealing names och gör det enkelt att förstå klassens syfte. |
| validateDateFormat()    | Metodnamn   | Method Names                       | Metodnamnet `validateDateFormat()` är tydligt och koncist, vilket gör det lätt att förstå vad metoden avser att göra. Den signalerar direkt att den ansvarar för att validera formatet av ett datum. |
| UserNameValidator       | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör. Det är ett bra exempel på intention-revealing names, vilket gör koden lättare att förstå och använda. |
| validateUserName()      | Metodnamn   | Method Names                       | Metodnamnet använder ett verb och är tydlig. |
| AddressValidator        | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör. Det är en bra tillämpning av intention-revealing names eftersom den validerar hela adressen. |
| validateAddress()       | Metodnamn   | Method Names                       | Metodnamnet är tydligt och beskriver vad metoden gör. Att inkludera mer specifika namn för gatan, staden eller postnumret kan vara till hjälp. |
| StreetValidator         | Klassnamn   | Use Intention-Revealing Names      | Klassen har ett tydligt namn som beskriver syftet – att validera gatunamn. Det följer regeln om intention-revealing names. |
| validateStreet()        | Metodnamn   | Method Names                       | Metodnamnet är verbbaserat och tydligt. Det beskriver exakt vad det gör, vilket gör det till ett bra namn enligt Clean Code-regler. |
| CityValidator           | Klassnamn   | Use Intention-Revealing Names      | Klassen beskriver tydligt att den validerar städernas namn. Detta följer regeln om intention-revealing names och gör klassen lätt att förstå. |
| validateCity()          | Metodnamn   | Method Names                       | Metodnamnet är verbbaserat och tydligt, vilket gör det lätt att förstå syftet med funktionen. |
| FirstAndLastNameValidator | Klassnamn | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör. Det är ett bra exempel på intention-revealing names. |
| validateFirstAndLastName() | Metodnamn| Method Names                      | Metodnamnet är verbbaserat och tydligt. Det beskriver exakt vad det gör, vilket gör det till ett bra namn enligt Clean Code-regler. |
| AgeValidator            | Klassnamn   | Use Intention-Revealing Names      | Klassnamnet är tydligt och beskriver vad klassen gör. |
| validateAge()           | Metodnamn   | Method Names                       | Metodnamnet är verbbaserat och tydligt. |

### Reflektion och Regler

1. **Intention-Revealing Names:** Jag tycker att jag har gjort ett bra jobb med att namnge klasser och metoder på ett sätt som tydligt beskriver deras syfte. Klassnamnen som PostalCodeValidator, PhoneNumberValidator, PasswordValidator, EmailValidator, DateFormatValidator och UserNameValidator är bra exempel på intention-revealing names.
2. **Use Problem Domain Names:** Namnen på mina klasser är tydligt relaterade till problemområdet, vilket gör koden lätt att förstå för någon med relevant domänkunskap.
3. **Method Names:** Metodnamnen i dessa klasser är tydliga och beskriver vad de gör. Exempelvis `validateAddress()`, `validateStreet()`, och `validateCity()` förmedlar direkt vad de kontrollerar.
4. **Avoid Disinformation:** Inga av mina namn verkar vara vilseledande eller ge fel information. De är direkta och relevanta för det de representerar.
5. **Use Pronounceable Names:** Alla mina namn är lätta att uttala och förstå, vilket underlättar för kommunikation och samarbete.

## Kapitel 3

| Metodnamn           | Fil                   | Antal rader (utan whitespace) | Reflektioner                                                                                                                                                             |
|---------------------|-----------------------|------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| validateEmail       | emailValidator.js     | 26                           | **Do One Thing:** Metoden validerar e-postformatet och hanterar flera olika villkor. Varje steg kontrollerar en specifik aspekt av e-postvalideringen. Metoden skulle kunna förenklas genom att dela upp den i mindre funktioner som hanterar olika valideringssteg.<br>**Function Arguments:** Tar ett argument, vilket är bra.<br>**Common Monadic Form:** Det är en fråga som kontrollerar e-postens giltighet.<br>**Avoid Output Arguments:** Metoden returnerar resultat direkt utan att ändra externa tillstånd. |
| validatePostalCode  | postalCodeValidator.js | 23                           | **Do One Thing:** Metoden kontrollerar postnummer för USA, Sverige, Kanada och UK. Den separerar tydligt varje lands specifika regex och returnerar resultat baserat på vilket land som matchas.<br>**Function Arguments:** Tar ett argument.<br>**Common Monadic Form:** Metoden validerar om postnumret matchar något av de fyra ländernas format.<br>**Avoid Output Arguments:** Returnerar ett objekt med valideringsresultat utan att ändra externa tillstånd. |
| validatePhoneNumber | phoneNumberValidator.js | 23                           | **Do One Thing:** Validerar telefonnummer mot två format. Varje format kontrolleras tydligt.<br>**Function Arguments:** Använder ett argument.<br>**Common Monadic Form:** Det är en fråga som validerar telefonnumret.<br>**Avoid Output Arguments:** Metoden returnerar resultat direkt. |
| validatePassword    | passwordValidator.js  | 27                           | **Do One Thing:** Kontrollerar om lösenordet uppfyller vissa krav. Metoden hanterar en enda valideringsuppgift.<br>**Function Arguments:** Tar ett argument.<br>**Common Monadic Form:** Det är en fråga som validerar lösenordet.<br>**Avoid Output Arguments:** Returnerar resultat utan att ändra externa tillstånd. |
| validateDateFormat  | dateFormatValidator.js | 17                           | **Do One Thing:** Validerar datumformat. Även om det kontrollerar flera format är varje kontroll distinkt.<br>**Function Arguments:** Tar ett argument.<br>**Common Monadic Form:** Det är en fråga som validerar datumformatet.<br>**Avoid Output Arguments:** Returnerar resultat utan att modifiera externa tillstånd. |
| validateUserName    | userNameValidator.js | 12                           | **Do One Thing:** Validerar användarnamn enligt specifika regler. Metoden kontrollerar längd och tillåtna tecken.<br>**Function Arguments:** Tar ett argument.<br>**Common Monadic Form:** Det är en fråga som validerar användarnamnet.<br>**Avoid Output Arguments:** Returnerar resultat utan att ändra externa tillstånd. |
| validateStreet      | streetValidator.js    | 12                           | **Do One Thing:** Metoden kontrollerar om ett gatunamn endast innehåller bokstäver, siffror och mellanslag. Den hanterar en enda valideringsuppgift och följer principen om att göra en sak.<br>**Function Arguments:** Använder ett argument (gatunamnet).<br>**Common Monadic Form:** Det är en fråga som returnerar sant eller felaktigt beroende på om valideringen passerar.<br>**Avoid Output Arguments:** Returnerar ett objekt med valideringsresultatet utan att modifiera externa tillstånd. |
| validateCity        | cityValidator.js      | 12                           | **Do One Thing:** Metoden kontrollerar om ett stadsnamn endast innehåller bokstäver och mellanslag. Den följer principen om enkelhet genom att endast validera ett kriterium.<br>**Function Arguments:** Tar ett argument.<br>**Common Monadic Form:** Det är en fråga som validerar om namnet är korrekt.<br>**Avoid Output Arguments:** Returnerar ett objekt med valideringsresultat utan att ändra externa tillstånd. |
| validateAddress     | addressValidator.js   | 25                           | **Do One Thing:** Validerar en fullständig adress genom att använda `validateStreet`, `validatePostalCode`, och `validateCity`. Den bryter ner validering i separata steg för att uppfylla principen att göra en sak i varje steg.<br>**Function Arguments:** Tar in ett objekt med flera argument (gata, postnummer, stad).<br>**Common Monadic Form:** Metoden validerar varje del av adressen steg för steg och returnerar resultatet.<br>**Avoid Output Arguments:** Returnerar ett objekt utan att påverka externa tillstånd. |
| validateFirstAndLastName | firstAndLastNameValidator.js | 20                           | **Do One Thing:** Metoden validerar för- och efternamn genom att kontrollera att de endast innehåller bokstäver och inte överskrider en viss längd. Den hanterar en enda valideringsuppgift.<br>**Function Arguments:** Tar två argument (förnamn och efternamn).<br>**Common Monadic Form:** Det är en fråga som validerar om namnen är korrekta.<br>**Avoid Output Arguments:** Returnerar ett objekt med valideringsresultat utan att ändra externa tillstånd. |
| validateAge         | ageValidator.js       | 24                           | **Do One Thing:** Metoden validerar ålder genom att kontrollera om användaren är mellan 3 och 120 år gammal. Den hanterar en enda valideringsuppgift.<br>**Function Arguments:** Tar ett argument (datumformat).<br>**Common Monadic Form:** Det är en fråga som validerar om åldern är korrekt.<br>**Avoid Output Arguments:** Returnerar ett objekt med valideringsresultat utan att ändra externa tillstånd. |
| Totala rader             |                       | 221                          |                                                                                                                                                                            |
### Reflektion

Utifrån kapitel 3 har jag noterat att mina funktioner i stort sett följer principerna för små funktioner, tydliga namn och minimala argument. Dock finns det några områden som kan förbättras:

1. **Small!:** De flesta metoder i mina klasser är korta och koncisa, vilket bidrar till både läsbarhet och underhållbarhet. Medan `validateEmail` hanterar flera valideringsregler inom samma funktion, är längden på metoden hanterbar och ger en tydlig översikt över de kontroller som utförs. Även om det kan vara fördelaktigt att överväga att bryta ner den i ännu mindre funktioner, är den nuvarande strukturen fortfarande lätt att följa.

2. **Have No Side Effects:** Jag har noggrant följt principen att undvika sidoreffekter. Funktionerna returnerar resultat baserat på sina indata utan att ändra några globala variabler eller klassnivåegenskaper. Detta gör att funktionerna är mer förutsägbara och lätta att testa.

3. **Command Query Separation:** De flesta metoder följer denna princip genom att fokusera på att returnera valideringsresultat utan att utföra operationer som modifierar tillståndet. Jag ser att det är viktigt att hålla dessa två ansvarsområden åtskilda för att öka tydligheten och göra koden mer hanterbar.

4. **Argument Objects:** Jag strävar efter att hålla antalet argument i varje funktion till ett minimum. Många av mina funktioner tar endast ett argument, vilket är en bra praxis. För funktioner som kräver flera argument, som `validateAddress`, överväger jag att gruppera argumenten i ett objekt för att öka tydligheten och underlätta framtida ändringar.

5. **Descriptive Names:** Jag ser värdet i att använda beskrivande namn för att öka kodens läsbarhet. Tydliga och informativa namn gör det lättare för andra utvecklare att förstå koden och dess syfte. Att använda verb och substantiv strategiskt kan också bidra till bättre dokumentation genom namnen själva.